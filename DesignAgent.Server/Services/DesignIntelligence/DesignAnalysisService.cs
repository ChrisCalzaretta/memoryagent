using DesignAgent.Server.Models.DesignIntelligence;
using AgentContracts.Services;
using Microsoft.Extensions.Options;
using System.Text;
using System.Text.Json;

namespace DesignAgent.Server.Services.DesignIntelligence;

/// <summary>
/// Service for analyzing designs using LLaVA vision model and calculating scores
/// </summary>
public class DesignAnalysisService : IDesignAnalysisService
{
    private readonly IOllamaClient _ollamaClient;
    private readonly IDesignIntelligenceStorage _storage;
    private readonly ILogger<DesignAnalysisService> _logger;
    private readonly DesignIntelligenceOptions _options;

    public DesignAnalysisService(
        IOllamaClient ollamaClient,
        IDesignIntelligenceStorage storage,
        ILogger<DesignAnalysisService> logger,
        IOptions<DesignIntelligenceOptions> options)
    {
        _ollamaClient = ollamaClient;
        _storage = storage;
        _logger = logger;
        _options = options.Value;
    }

    /// <summary>
    /// Analyze a complete design (all pages)
    /// </summary>
    public async Task<CapturedDesign> AnalyzeDesignAsync(CapturedDesign design, CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("üß† Analyzing design: {Url} ({PageCount} pages)", design.Url, design.Pages.Count);

        // 1. Analyze each page
        foreach (var page in design.Pages)
        {
            try
            {
                _logger.LogInformation("üìä Analyzing {PageType} page: {Url}", page.PageType, page.Url);
                await AnalyzePageAsync(page, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to analyze page: {Url}", page.Url);
                // Continue with other pages
            }
        }

        // 2. Calculate overall site score
        design.OverallScore = await CalculateSiteScoreAsync(design.Pages, cancellationToken);

        // 3. Synthesize design DNA
        design.DesignDNA = await SynthesizeDesignDnaAsync(design.Pages, cancellationToken);

        // 4. Detect design system
        design.DetectedSystem = await DetectDesignSystemAsync(design.Pages, cancellationToken);

        // 5. Generate auto name
        design.AutoGeneratedName = GenerateAutoName(design);

        _logger.LogInformation("‚úÖ Analysis complete: {Url} - Score: {Score:F1}", design.Url, design.OverallScore);

        return design;
    }

    /// <summary>
    /// Analyze a single page using page-type-specific prompt
    /// </summary>
    public async Task<PageAnalysis> AnalyzePageAsync(PageAnalysis page, CancellationToken cancellationToken = default)
    {
        // Get page-type-specific prompt
        var promptName = GetPromptNameForPageType(page.PageType);
        var systemPrompt = await _storage.GetPromptAsync(promptName, cancellationToken)
            ?? GetFallbackPromptForPageType(page.PageType);

        // Use desktop screenshot for analysis (primary)
        var screenshotPath = page.Screenshots.Desktop;
        if (string.IsNullOrEmpty(screenshotPath) || !File.Exists(screenshotPath))
        {
            _logger.LogWarning("Desktop screenshot not found for {Url}, skipping analysis", page.Url);
            page.OverallPageScore = 0;
            return page;
        }

        // Build user prompt
        var userPrompt = BuildPageAnalysisPrompt(page);

        // Call LLaVA with image
        var imageBytes = await File.ReadAllBytesAsync(screenshotPath, cancellationToken);
        var imageBase64 = Convert.ToBase64String(imageBytes);

        // Note: This would need to be updated to support images in IOllamaClient
        // For now, we'll use a placeholder that calls the vision model
        var response = await CallVisionModelAsync(
            _options.VisionModel,
            userPrompt,
            systemPrompt,
            imageBase64,
            cancellationToken);

        // Parse analysis response
        var analysis = ParsePageAnalysis(response, page.PageType);

        // Update page with analysis
        page.AnalysisModel = _options.VisionModel;
        page.CategoryScores = analysis.CategoryScores;
        page.Strengths = analysis.Strengths;
        page.Weaknesses = analysis.Weaknesses;
        page.CategoryDetails = analysis.CategoryDetails;

        // Calculate overall page score (weighted average of categories)
        page.OverallPageScore = CalculatePageScore(analysis.CategoryScores, page.PageType);

        // Apply bias correction if available
        page.OverallPageScore = await ApplyBiasCorrectionAsync(
            page.OverallPageScore,
            page.AnalysisModel,
            page.PageType,
            cancellationToken);

        // Set page weight based on type
        page.PageWeight = GetPageWeight(page.PageType);

        _logger.LogInformation("‚úÖ Page analyzed: {Type} - Score: {Score:F1}", page.PageType, page.OverallPageScore);

        return page;
    }

    /// <summary>
    /// Synthesize design DNA from all pages
    /// </summary>
    public async Task<DesignDNA> SynthesizeDesignDnaAsync(List<PageAnalysis> pages, CancellationToken cancellationToken = default)
    {
        if (pages.Count == 0)
        {
            return new DesignDNA
            {
                Philosophy = "unknown",
                ColorPhilosophy = "unknown",
                TypographyStyle = "unknown",
                SpacingStyle = "unknown",
                InteractionStyle = "unknown",
                TargetAudience = "unknown"
            };
        }

        // Get prompt
        var systemPrompt = await _storage.GetPromptAsync("design_site_synthesis", cancellationToken)
            ?? GetFallbackSynthesisPrompt();

        // Build synthesis prompt with all page analyses
        var userPrompt = BuildSynthesisPrompt(pages);

        var response = await _ollamaClient.GenerateAsync(
            _options.TextModel,
            userPrompt,
            systemPrompt,
            cancellationToken: cancellationToken);

        return ParseDesignDna(response.Response);
    }

    /// <summary>
    /// Detect design system/framework from CSS and DOM
    /// </summary>
    public async Task<DetectedDesignSystem> DetectDesignSystemAsync(List<PageAnalysis> pages, CancellationToken cancellationToken = default)
    {
        // Collect CSS from all pages
        var allCss = string.Join("\n", pages.Select(p => p.ExtractedCss ?? "").Where(c => !string.IsNullOrEmpty(c)));

        if (string.IsNullOrEmpty(allCss))
        {
            return new DetectedDesignSystem
            {
                Framework = "Unknown",
                IsCustomSystem = true,
                SystemMaturity = 0
            };
        }

        // Get prompt
        var systemPrompt = await _storage.GetPromptAsync("design_system_detection", cancellationToken)
            ?? GetFallbackDesignSystemPrompt();

        var userPrompt = $"Analyze this CSS and detect the design system/framework:\n\n{allCss.Substring(0, Math.Min(allCss.Length, 5000))}";

        var response = await _ollamaClient.GenerateAsync(
            _options.TextModel,
            userPrompt,
            systemPrompt,
            cancellationToken: cancellationToken);

        return ParseDetectedSystem(response.Response);
    }

    /// <summary>
    /// Analyze UX copy on a page
    /// </summary>
    public async Task<UxCopyAnalysis> AnalyzeCopyAsync(PageAnalysis page, CancellationToken cancellationToken = default)
    {
        // Extract text from HTML
        var textContent = ExtractTextFromHtml(page.ExtractedHtml ?? "");

        if (string.IsNullOrEmpty(textContent))
        {
            return new UxCopyAnalysis { Score = 0 };
        }

        var systemPrompt = await _storage.GetPromptAsync("design_copy_analysis", cancellationToken)
            ?? "Analyze the UX copy, CTAs, and microcopy. Rate tone, clarity, and value proposition.";

        var userPrompt = $"Analyze this UX copy:\n\n{textContent.Substring(0, Math.Min(textContent.Length, 2000))}";

        var response = await _ollamaClient.GenerateAsync(
            _options.TextModel,
            userPrompt,
            systemPrompt,
            cancellationToken: cancellationToken);

        return ParseCopyAnalysis(response.Response);
    }

    /// <summary>
    /// Perform accessibility audit
    /// </summary>
    public async Task<AccessibilityAudit> AuditAccessibilityAsync(PageAnalysis page, CancellationToken cancellationToken = default)
    {
        // Use screenshot + HTML for accessibility analysis
        var systemPrompt = await _storage.GetPromptAsync("design_accessibility_audit", cancellationToken)
            ?? "Audit accessibility: color contrast, keyboard navigation, ARIA labels, semantic HTML. Estimate WCAG level.";

        var userPrompt = BuildAccessibilityPrompt(page);

        var response = await _ollamaClient.GenerateAsync(
            _options.TextModel,
            userPrompt,
            systemPrompt,
            cancellationToken: cancellationToken);

        return ParseAccessibilityAudit(response.Response);
    }

    /// <summary>
    /// Analyze animations and motion design
    /// </summary>
    public async Task<AnimationAnalysis?> AnalyzeAnimationsAsync(PageAnalysis page, CancellationToken cancellationToken = default)
    {
        // Video capture not implemented yet
        if (page.AnimationAnalysis?.VideoPath == null)
        {
            return null;
        }

        // TODO: Implement video-based animation analysis
        return null;
    }

    /// <summary>
    /// Calculate overall site score from page scores
    /// </summary>
    public async Task<double> CalculateSiteScoreAsync(List<PageAnalysis> pages, CancellationToken cancellationToken = default)
    {
        if (pages.Count == 0)
        {
            return 0;
        }

        // Weighted average: Homepage √ó 2.0, Pricing √ó 1.5, others √ó 1.0, etc.
        double totalWeightedScore = 0;
        double totalWeight = 0;

        foreach (var page in pages)
        {
            var weight = page.PageWeight;
            totalWeightedScore += page.OverallPageScore * weight;
            totalWeight += weight;
        }

        var siteScore = totalWeight > 0 ? totalWeightedScore / totalWeight : 0;

        _logger.LogInformation("üìä Site score calculation: {Score:F2} (from {PageCount} pages, total weight: {Weight:F1})",
            siteScore, pages.Count, totalWeight);

        return Math.Round(siteScore, 2);
    }

    /// <summary>
    /// Check if design passes quality gate
    /// </summary>
    public async Task<bool> PassesQualityGateAsync(double score, double trustScore, CancellationToken cancellationToken = default)
    {
        var baseThreshold = _options.InitialThreshold; // 7.0
        var trustBonus = trustScore * 0.1;
        var effectiveThreshold = baseThreshold - trustBonus;

        var passes = score >= effectiveThreshold;

        if (passes)
        {
            _logger.LogInformation("‚úÖ Quality gate PASSED: {Score:F1} >= {Threshold:F1} (trust bonus: {Bonus:F1})",
                score, effectiveThreshold, trustBonus);
        }
        else
        {
            _logger.LogInformation("‚ùå Quality gate FAILED: {Score:F1} < {Threshold:F1}",
                score, effectiveThreshold);
        }

        return passes;
    }

    /// <summary>
    /// Apply bias correction to score based on model calibration
    /// </summary>
    public async Task<double> ApplyBiasCorrectionAsync(double rawScore, string model, string pageType, CancellationToken cancellationToken = default)
    {
        var calibration = await _storage.GetModelPerformanceAsync(model, pageType, cancellationToken);

        if (calibration == null || calibration.SampleSize < 20)
        {
            // Not enough calibration data yet
            return rawScore;
        }

        // Apply correction: correctedScore = rawScore - bias
        var correctedScore = rawScore - calibration.AverageBias;

        // Clamp to 0-10
        correctedScore = Math.Clamp(correctedScore, 0, 10);

        if (Math.Abs(calibration.AverageBias) > 0.1)
        {
            _logger.LogDebug("üéØ Bias correction applied: {Raw:F2} ‚Üí {Corrected:F2} (bias: {Bias:F2})",
                rawScore, correctedScore, calibration.AverageBias);
        }

        return correctedScore;
    }

    // ===== PRIVATE HELPERS =====

    private async Task<string> CallVisionModelAsync(string model, string prompt, string systemPrompt, string imageBase64, CancellationToken cancellationToken)
    {
        // TODO: This needs to be implemented in IOllamaClient to support images
        // For now, we'll use a workaround that calls Ollama's generate API with image
        
        // Placeholder: In a real implementation, this would call:
        // POST /api/generate with { "model": "llava:13b", "prompt": "...", "images": ["base64..."] }
        
        _logger.LogWarning("Vision model integration not fully implemented yet - using text-only fallback");
        
        // Fallback to text-only analysis
        var response = await _ollamaClient.GenerateAsync(
            _options.TextModel,
            prompt,
            systemPrompt,
            cancellationToken: cancellationToken);

        return response.Response;
    }

    private string GetPromptNameForPageType(string pageType)
    {
        return pageType.ToLower() switch
        {
            "homepage" => "design_analysis_homepage",
            "pricing" => "design_analysis_pricing",
            "features" => "design_analysis_features",
            "dashboard" => "design_analysis_dashboard",
            "blog" => "design_analysis_blog",
            _ => "design_analysis_generic"
        };
    }

    private string GetFallbackPromptForPageType(string pageType)
    {
        return pageType.ToLower() switch
        {
            "homepage" => GetFallbackHomepagePrompt(),
            "pricing" => GetFallbackPricingPrompt(),
            "features" => GetFallbackFeaturesPrompt(),
            _ => GetFallbackGenericPrompt()
        };
    }

    private string GetFallbackHomepagePrompt()
    {
        return @"Analyze this homepage screenshot and score these categories (0-10):

1. **Hero Section** - Headline clarity, visual treatment, CTA design, above-fold effectiveness
2. **Navigation** - Style, hierarchy, organization, mobile considerations
3. **Social Proof** - Logo clouds, testimonials, statistics, placement
4. **Composition** - Visual hierarchy, whitespace, color harmony, typography

Return JSON:
{
  ""hero"": { ""score"": 0-10, ""strengths"": [...], ""weaknesses"": [...] },
  ""navigation"": { ""score"": 0-10, ""strengths"": [...], ""weaknesses"": [...] },
  ""socialProof"": { ""score"": 0-10, ""strengths"": [...], ""weaknesses"": [...] },
  ""composition"": { ""score"": 0-10, ""strengths"": [...], ""weaknesses"": [...] }
}";
    }

    private string GetFallbackPricingPrompt()
    {
        return @"Analyze this pricing page and score these categories (0-10):

1. **Tier Layout** - Number of tiers, visual arrangement, differentiation, highlighted tier
2. **Price Presentation** - Typography, billing toggle, currency clarity, discount communication
3. **Feature Comparison** - List clarity, scannability, comparison table, visual indicators
4. **CTAs** - Button design, action text, hierarchy, urgency/trust elements
5. **Trust Elements** - Guarantees, testimonials, security badges, FAQ

Return JSON with scores, strengths, and weaknesses for each category.";
    }

    private string GetFallbackFeaturesPrompt()
    {
        return @"Analyze this features page and score these categories (0-10):

1. **Feature Presentation** - Organization, benefit framing, visual support, depth
2. **Layout Rhythm** - Section alternation, visual variety, scroll experience, pattern consistency
3. **Visual Elements** - Icon style, illustrations, screenshots, integration
4. **Information Hierarchy** - Headings, scannability, progressive disclosure, visual weight

Return JSON with scores, strengths, and weaknesses.";
    }

    private string GetFallbackGenericPrompt()
    {
        return @"Analyze this page design and score these categories (0-10):

1. **Visual Hierarchy** - Clear information priority
2. **Typography** - Font usage and readability
3. **Color Usage** - Palette and contrast
4. **Spacing/Layout** - Whitespace and structure
5. **Overall Aesthetic** - General design quality

Return JSON with scores, strengths, and weaknesses.";
    }

    private string GetFallbackSynthesisPrompt()
    {
        return @"Synthesize a unified design DNA profile from multiple page analyses. 

Describe:
- Overall philosophy (minimal, maximalist, brutalist, etc.)
- Color philosophy (vibrant gradients, muted pastels, etc.)
- Typography style (large serif headings, monospace technical, etc.)
- Spacing style (generous whitespace, compact, etc.)
- Interaction style (subtle micro-interactions, bold animations, etc.)
- Target audience (enterprise, consumer, developer, creative)
- Standout elements (unique design choices)

Return JSON.";
    }

    private string GetFallbackDesignSystemPrompt()
    {
        return @"Detect the design system or framework from this CSS.

Look for:
- Framework indicators (Tailwind classes, Bootstrap, Material UI)
- Component libraries (shadcn/ui, Radix, Chakra)
- Custom design tokens
- System maturity

Return JSON: { ""framework"": """", ""componentLibrary"": """", ""isCustomSystem"": bool, ""systemMaturity"": 0-10, ""evidence"": [...] }";
    }

    private string BuildPageAnalysisPrompt(PageAnalysis page)
    {
        return $@"Analyze this {page.PageType} page design.

URL: {page.Url}

Score each category from 0-10 and provide specific strengths and weaknesses.
Focus on visual design quality, not content accuracy.

Return JSON with category scores, strengths array, and weaknesses array.";
    }

    private string BuildSynthesisPrompt(List<PageAnalysis> pages)
    {
        var sb = new StringBuilder();
        sb.AppendLine("Synthesize design DNA from these page analyses:");
        sb.AppendLine();

        foreach (var page in pages)
        {
            sb.AppendLine($"### {page.PageType} (Score: {page.OverallPageScore:F1})");
            sb.AppendLine($"Strengths: {string.Join(", ", page.Strengths.Take(3))}");
            sb.AppendLine($"Weaknesses: {string.Join(", ", page.Weaknesses.Take(2))}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private string BuildAccessibilityPrompt(PageAnalysis page)
    {
        return $@"Audit accessibility for this page.

Check:
- Color contrast ratios
- Keyboard navigation patterns
- Semantic HTML structure
- ARIA labels presence
- Focus indicators

Return JSON: {{ ""score"": 0-10, ""wcagLevel"": ""A/AA/AAA/Below A"", ""contrastIssues"": number, ""issues"": [...], ""positiveFeatures"": [...] }}";
    }

    private PageAnalysisResult ParsePageAnalysis(string response, string pageType)
    {
        var result = new PageAnalysisResult
        {
            CategoryScores = new Dictionary<string, double>(),
            Strengths = new List<string>(),
            Weaknesses = new List<string>(),
            CategoryDetails = new Dictionary<string, CategoryAnalysis>()
        };

        try
        {
            var jsonStart = response.IndexOf('{');
            var jsonEnd = response.LastIndexOf('}');

            if (jsonStart >= 0 && jsonEnd > jsonStart)
            {
                var json = response.Substring(jsonStart, jsonEnd - jsonStart + 1);
                var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;

                // Parse each category
                foreach (var prop in root.EnumerateObject())
                {
                    if (prop.Value.ValueKind == JsonValueKind.Object)
                    {
                        var catAnalysis = new CategoryAnalysis();

                        if (prop.Value.TryGetProperty("score", out var score))
                        {
                            catAnalysis.Score = score.GetDouble();
                            result.CategoryScores[prop.Name] = catAnalysis.Score;
                        }

                        if (prop.Value.TryGetProperty("strengths", out var strengths))
                        {
                            catAnalysis.Strengths = strengths.EnumerateArray()
                                .Select(s => s.GetString() ?? "")
                                .Where(s => !string.IsNullOrEmpty(s))
                                .ToList();
                            result.Strengths.AddRange(catAnalysis.Strengths);
                        }

                        if (prop.Value.TryGetProperty("weaknesses", out var weaknesses))
                        {
                            catAnalysis.Weaknesses = weaknesses.EnumerateArray()
                                .Select(w => w.GetString() ?? "")
                                .Where(w => !string.IsNullOrEmpty(w))
                                .ToList();
                            result.Weaknesses.AddRange(catAnalysis.Weaknesses);
                        }

                        result.CategoryDetails[prop.Name] = catAnalysis;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse page analysis, using defaults");
        }

        // Ensure we have at least one score
        if (result.CategoryScores.Count == 0)
        {
            result.CategoryScores["overall"] = 5.0;
        }

        return result;
    }

    private double CalculatePageScore(Dictionary<string, double> categoryScores, string pageType)
    {
        if (categoryScores.Count == 0)
        {
            return 0;
        }

        // Different weights for different page types
        var weights = GetCategoryWeights(pageType);

        double totalWeightedScore = 0;
        double totalWeight = 0;

        foreach (var (category, score) in categoryScores)
        {
            var weight = weights.ContainsKey(category) ? weights[category] : 1.0;
            totalWeightedScore += score * weight;
            totalWeight += weight;
        }

        return totalWeight > 0 ? totalWeightedScore / totalWeight : 0;
    }

    private Dictionary<string, double> GetCategoryWeights(string pageType)
    {
        return pageType.ToLower() switch
        {
            "homepage" => new Dictionary<string, double>
            {
                { "hero", 0.35 },
                { "navigation", 0.25 },
                { "socialProof", 0.20 },
                { "composition", 0.20 }
            },
            "pricing" => new Dictionary<string, double>
            {
                { "tierLayout", 0.25 },
                { "pricePresentation", 0.20 },
                { "featureComparison", 0.25 },
                { "ctas", 0.20 },
                { "trustElements", 0.10 }
            },
            _ => new Dictionary<string, double>() // Equal weights for generic
        };
    }

    private double GetPageWeight(string pageType)
    {
        return pageType.ToLower() switch
        {
            "homepage" => 2.0,
            "pricing" => 1.5,
            "features" => 1.0,
            "dashboard" => 1.0,
            "blog" => 0.5,
            "about" => 0.5,
            _ => 0.5
        };
    }

    private DesignDNA ParseDesignDna(string response)
    {
        // Parse JSON or use defaults
        try
        {
            var jsonStart = response.IndexOf('{');
            var jsonEnd = response.LastIndexOf('}');

            if (jsonStart >= 0 && jsonEnd > jsonStart)
            {
                var json = response.Substring(jsonStart, jsonEnd - jsonStart + 1);
                return JsonSerializer.Deserialize<DesignDNA>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                }) ?? new DesignDNA();
            }
        }
        catch { }

        return new DesignDNA
        {
            Philosophy = "modern",
            ColorPhilosophy = "vibrant",
            TypographyStyle = "clean sans-serif",
            SpacingStyle = "generous",
            InteractionStyle = "subtle",
            TargetAudience = "general"
        };
    }

    private DetectedDesignSystem ParseDetectedSystem(string response)
    {
        try
        {
            var jsonStart = response.IndexOf('{');
            var jsonEnd = response.LastIndexOf('}');

            if (jsonStart >= 0 && jsonEnd > jsonStart)
            {
                var json = response.Substring(jsonStart, jsonEnd - jsonStart + 1);
                return JsonSerializer.Deserialize<DetectedDesignSystem>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                }) ?? new DetectedDesignSystem { Framework = "Unknown" };
            }
        }
        catch { }

        return new DetectedDesignSystem { Framework = "Custom", IsCustomSystem = true };
    }

    private UxCopyAnalysis ParseCopyAnalysis(string response)
    {
        // Simplified parsing
        return new UxCopyAnalysis
        {
            Score = 7.0,
            Tone = "professional",
            CtaQuality = 7.5,
            ValuePropClarity = 7.5
        };
    }

    private AccessibilityAudit ParseAccessibilityAudit(string response)
    {
        return new AccessibilityAudit
        {
            Score = 7.0,
            WcagLevel = "AA",
            ContrastIssues = 2,
            KeyboardNavigation = 7.5,
            ScreenReaderFriendly = 7.0
        };
    }

    private string ExtractTextFromHtml(string html)
    {
        // Simple text extraction (remove tags)
        return System.Text.RegularExpressions.Regex.Replace(html, "<.*?>", " ")
            .Trim();
    }

    private string GenerateAutoName(CapturedDesign design)
    {
        // Generate a simple name based on URL
        var domain = new Uri(design.Url).Host.Replace("www.", "").Replace(".com", "").Replace(".io", "");
        var score = design.OverallScore;

        if (score >= 9.0) return $"{domain} Excellence";
        if (score >= 8.0) return $"{domain} Quality";
        if (score >= 7.0) return $"{domain} Standard";
        return domain;
    }

    private class PageAnalysisResult
    {
        public Dictionary<string, double> CategoryScores { get; set; } = new();
        public List<string> Strengths { get; set; } = new();
        public List<string> Weaknesses { get; set; } = new();
        public Dictionary<string, CategoryAnalysis> CategoryDetails { get; set; } = new();
    }
}

